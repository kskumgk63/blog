---
title: "Learning Test Driven Disign"
date: 2020-04-30T20:33:56+09:00
draft: true

categories: ["development"]
tags: []
author: "Keisuke Umegaki"
---

# memo

Gherkinはテストのための記法の1つで、「こういう状態のとき、こういう動作を行えば、こうなることが期待される」という形式で記述していくものです。
ビアソンさんは「たとえ実際にテストでは使わなくとも、Gherkinを書くことでアプリがどういう動作を期待されているのか理解しやすくなる」と述べています。
自然言語で書ける。英語でも日本語でもOK。
テスト仕様部分とロジック部分をfeatureとstepで分離しており何がテストされているか分かり易い。

```
Given: 事前状態
When: 操作
Then: 事後状態
```

（例）
Given: ユーザーはログインしている
When: タスクを登録する
Then: タスクがDBに登録されていること

# レビュー 

- 自動化されたテストが失敗したときのみ新しいコードを書く
- 重複を削除する

この2つのシンプルなルールに従って開発する手法をテスト駆動開発（以下、TDD）と言います。
本書からは、「他国通貨」というテーマで実際にどうTDDでコーディングしていくのかを本に掲載されているコードを追いながら、本（著者）とペアプログラミングをしているかのようにTDD実践方法を学べます。
また「きれいな動作するコード」を書くためにTDDがなぜ必要なのか、TDDはどのような課題を解決するのか、TDDを導入する利点を紹介していて、それらを読んで僕は、これからはTDDでプログラミングをしていこうと決心しました。
「ユニットテストを書くより開発スピード優先だ」と思っている方にぜひとも読んでいただきたい本です。

# 本書の要点

## 要点1 最初にテストを書く

TDDの実践方法

1. まずはテストを最初に書く
2. すべてのテストを走らせて、新しいテストの失敗を確認する
3. 小さな変更を加える
4. すべてのテストを実行して、すべて成功することを確認する
5. リファクタリングを行って重複を除去する

実装よりも先にテストを書きます。そのコードに求められる動作（仕様）を明記していくイメージでテストケースを作成していきます。最初からテストケースが十分でなくともいいですが、適宜追加していきます。
ちなみに**テストは、「不安が退屈になる」まで書く必要**があり、**消しても不安にならないのならテストケースを削除することが可能**です。
そして、そのテストケースがすべて通るように実装を進めていきます。一通りテストが通るようになったら重複を削除する、可読性を上げるなどリファクタリングを進めていきます。これは少しずつ変更して、都度テストに通ることを確認してください。

## 要点2

## 要点3

# テスト駆動開発から学んだこと

> テスト駆動開発は、設計のひらめきが正しい瞬間に訪れることを保証するものではない。しかし、自信を与えてくれるテストときちんと手入れされたコードは、ひらめきへの備えであり、いざひらめいたときに、それを具現化するための備えでもある

## TDDの目的
フィードバックサイクルを健全に回し、 動作するきれいなコードを、より良いソフトウェア設計に至るためのひとつの状態として、 フィードバックサイクルを回し続けられるようにする手段のひとつがテスト駆動開発です。
目指したいのは "Cover and Modify" と呼ばれている状態です。 それは、安心して積極的にコードに手を入れることができて、もしそれに失敗してしまっても、すぐに失敗に気付けるし、すぐに元に戻せるので壊滅的なことにはならない状態です。 私たちに必要なのは、このような環境を作り、開発文化を作ることではないでしょうか。
むしろソフトウェアを作ってからがスタートで、市場のニーズや状況に適応して欲しいときに望ましい形に姿を変えることができて、変更しやすく手を入れ続けられるような、変化し続ける、変化し続けられるソフトウェアの方が資産になる時代です。
積極的にかつ自信を持って触り続けられるソフトウェアがずっと価値があるのです。
フィードバックループを常に回し続け、テストとリファクタリングを両輪にして不断の改善を続けるためのプログラミングプラクティスがテスト駆動開発であり、その改善のサイクルがテスト駆動開発の本質です。
これが昨今のソフトウェアの姿であり、そのためには、リリースのたびに爆弾処理のような思いでリリースをしていてはなりません。 全てが変わっていく世の中で、変化に対応できなければソフトウェアも事業も緩やかに死んでいきます。
爆弾処理のようなリリースとは、つまり勇気ではなくて蛮勇、度胸であり、度胸で開発しているからあんなことになるのですよね。
ソフトウェア業界を強く縛り付けてきた恐怖に対して、蛮勇ではなく道具と技術をもって対抗する手段を探し育てる方向でソフトウェア開発の世界は進化が続いてきました。

## TDDの進め方

- コードを書く前にテストコードを書く
- 自動化されたテストが失敗したときのみ新しいコードを書く
- 重複を除去する（コピーアンドペーストは抽象化の敗北）

## TDDのリズム

ゴール：「動作するきれいなコード」を目指す。

- 要件を満たす
- バグがない
- 可読性、保守性が高い

これは、偉大なプログラマでも難しい。普通のプログラマならなおさら。
なので、テストを書いてたくさん失敗してコードを磨き続けよう。

1. まずはテストを最初に書く
2. すべてのテストを走らせて、新しいテストの失敗を確認する
3. 小さな変更を加える
4. すべてのテストを実行して、すべて成功することを確認する
5. リファクタリングを行って重複を除去する

## テストをいつ書くか

テスト対象の実装前。プログラマの仕事は機能を実装することなので実装を終えるとテストは忘れられるだろう。

## 自動テストが解決したい問題

- 機能が増える毎に回帰テストの実行コストが増える
  - 増えた結果、必要なテストが実施されなくなり、バグが発生する
  - リファクタリングがしにくくなる
- テストコードが積み上がっていくことで回帰テストコストが低いまま維持されて、品質維持が容易になる
- リファクタリングがしやすくなるのでコード品質も向上させやすい
- コードの正しい挙動がわかる（担当者がいなくとも正しい挙動がわかる）
  - ドキュメントと違って古くならない実行可能ドキュメント

自動化は人間の忍耐力の限界を補います。
ソフトウェア開発は小さく定型的な繰り返し作業が非常に多いという特徴があります。 定義ファイルを書き換えたらコードを自動生成したり、 コードを書き換えたらビルドしてテストを行ったり、 テスト結果を集めてレポートにしたり、 手順書に沿ってリリース対象のファイルをコピーしてパッケージングしたりと、 ひとつひとつは小さいタスクの繰り返しでソフトウェア開発は成り立っています。
人間は、考えること、創造的に脳を働かせるのはまあまあ得意なのですが、 決まったことを寸分違わず繰り返せと言われても、だんだん飽きてくるし疲れてきます。 飽きたり疲れたりすると作業の精度が落ちていきます。
それに対して、機械の方は、最近は機械学習や人工知能によってだいぶ状況は変わってきてはいますが、 基本的な性質としては、創造性は人間よりも劣るけれども、繰り返し作業に強い。 機械は与えられたタスクを疲れずに淡々と同じ精度で続けることができます。
なので、人間の得意不得意、機械の得意不得意をそれぞれ相互補完しようというのが自動化の考え方です。
例えば、人間がずっと手順書に沿って作業していくのではなく、手順書の代わりに自動化スクリプトを書きます。
すると、それまで人間の手数が15ステップの操作手順だったものが、たとえば4つのスクリプトを順番に動かせば良くなるだけになります。 さらにその4つのスクリプトを起動する代わりに2つのボタンを押せば良くなり、ついには1つのボタンを押すだけで作業が完了するようになる、といった具合です。
人間が必要な手数を減らすことで、人間は頭を使い、機械が代わりに仕事をする方にシフトしよう、という考え方ですね。
そのように作業のステップを減らしていって、1アクションでできるところまで行ったときに、人間はさらにその先を求めます。 つまり、1アクションすらしたくないと思い始めるのです。人間は基本的には怠惰な生きものだからですね。
`Automation`（自動化） のさらに先には `Autonomation`（自働化）があります。
`Autonomation` はトヨタ生産方式（TPS）の言葉で、自ら動くではなく、自ら働くと書きます。 読みが同じですから、後者は「ニンベンの付いた自動化」と呼ばれたりもします。
人間は能動的に1アクションすらしたくないので、機械の方が常に働いていて、 何かおかしなことがあるかどうかを機械が自分で判断し、報告すべきことがあったときだけ人間に伝えてくれれば良いじゃないか、 というのがトヨタ生産方式の自働化の考え方です。 アクションの向きを逆にしたのですね。 異常なことがなければ何も伝えてこなくて良い。便りのないのは元気な知らせというわけです。
すると、人間と機械の協業は完全に非同期になります。
人間は人間のペースで創造的な仕事を続けていれば良くて、何かおかしなことがあったときだけ機械が割り込んでくる状態を作れます。
これが目指している `Autonomation`（自働化）の世界です。 それを具現化しているのが例えば Continuous Integration、 継続的インテグレーションです。
プログラマがコミットしてプッシュしたらコンパイルとビルドとテストが自動的に走って、 ビルドやテストが失敗したときだけ開発者に知らせてくれれば良くなります。 また、コードの変更がなくとも、CIサーバは決められた間隔で常にビルドやテストを繰り返し、失敗したときは開発者に知らせてくれます。これで「コードに触っていないけど壊れた」状態を検知できるわけです。

# TDDが解決したい課題

## 十分なテストが書かれない
- 後からテストを書くと必要なパターンの認識が漏れる
- カバレッジだと足りないことがわかるが、十分であることの根拠に使えない
  
TDDだとコードとテストコードがセットで増えていくので十分なテストが書かれやすい

- テストを書く時点で、テストが書きにくい設計であることに気がつける

# TDD導入の懸念点

- TDDだけでは品質を担保できない。UTだけではだめ。
- テスト実装工数が無駄？長期的に考えるとテスト実装工数はペイできる。

## TDDを身につける

### 一歩の大きさはどのくらいか
- 各々のテストがどのくらいカバーするべきか
- リファクタリングの過程で中継地点をどのくらい作るか

自信を持って行うためにテストテストを書くのだ。ロジックに1行追加したり、10行くらい変更してもテストが書かれていれば自信をもって前に進める。
デバッグがすぐに行える。正しいふるまいがブレずに明確にあるからだ。

リファクタリングを行う際には、ステップをたくさんの小さなステップに分割することを心がける。小さな小さなリファクタリングを20回手作業でやってみて、振り返ったときにステップをいくつか飛ばせるか実験する。

### やる必要のないテストはあるのか

「不安が退屈になる」というのが１つの指標になる。ただしユニットテストの実装は自分が書いたコードに限る。

### 良いテストを見分けることができるか

テスト設計から立ち上る悪臭を敏感に察知して教えてくれる。炭鉱のカナリアだ。
設計に問題を抱えている場合、テストには以下のような兆候が現れる。

#### 前準備に要するコードが長い
アサーションを行うテスト対象オブジェクトの準備に100行のコードが必要なのであれば、何かがおかしい。
そのオブジェクトは大きすぎるので分割するほうが良い。

#### 前準備コードの重複
共通の前準備コードを配置する場所がすぐに見つからな良いのは、お互いに密に関連しあうオブジェクトが多すぎることを示唆している。

#### テスト実行時間が長い
TDDにおいては、テスト実行がかかりすぎると実行の頻度は低くなる。
長い実行時間は、アプリケーションのいち部を切り出したテストが難しいことを示唆している。
部分的なテストが難しいのは設計の問題であるため。設計の観点から取り組まなければならない。

#### 脆いテスト
思わぬタイミングで失敗するテストは、アプリケーションのどこかが意外な形で他の部分に影響している可能背を示唆している。
2つの部分の関係性を経つか、または統合するなどして、離れた箇所から影響を控除するように設計し直さなければならない。

## どのようなときにテストを消すべきか
テストの数は多いに越したことがないが、もし2つのテストの間に重複が発生した場合、2つとも残すべきか？？

- テストを削除して自信が減るのなら決して削除してはならない
- 2つのテストが読み手に異なるシナリオに見えるなら消さずにそのままにしておこう

# 参考

https://t-wada.hatenablog.jp/entry/clean-code-that-works
